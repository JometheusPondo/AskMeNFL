#!/usr/bin/env python3
"""
FastAPI Backend for NFL Natural Language Query System
Exposes REST API endpoints for React frontend
"""
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
import sqlite3
import pandas as pd
import requests
import json
import time
import re
import asyncio
import logging
from contextlib import asynccontextmanager

# Logging setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Pydantic models for API
class QueryRequest(BaseModel):
    question: str = Field(..., description="Natural language NFL question")
    include_sql: bool = Field(default=False, description="Include generated SQL in response")

class QueryResponse(BaseModel):
    success: bool
    data: Optional[List[Dict[str, Any]]] = None
    columns: Optional[List[str]] = None
    sql_query: Optional[str] = None
    error: Optional[str] = None
    timing: Dict[str, float] = Field(default_factory=dict)
    rows_returned: int = 0

class DatabaseStatus(BaseModel):
    connected: bool
    total_plays: int = 0
    available_quarterbacks: List[str] = Field(default_factory=list)
    error: Optional[str] = None

class NFLQueryService:
    def __init__(self, db_path: str = "nfl.db"):
        self.db_path = db_path
        self.ollama_url = "http://localhost:11434/api/generate"
        self.name_mappings = {}
        self.qb_names = []
        self._initialize_db()
        self._build_name_mappings()
    
    def _initialize_db(self):
        """Initialize database connection and test it"""
        try:
            conn = sqlite3.connect(self.db_path, check_same_thread=False)
            cursor = conn.execute("SELECT COUNT(*) FROM plays")
            total_plays = cursor.fetchone()[0]
            conn.close()
            self.db_connected = True
            self.total_plays = total_plays
            logger.info(f"Database connected successfully. {total_plays:,} plays loaded.")
        except Exception as e:
            self.db_connected = False
            self.db_error = str(e)
            logger.error(f"Database connection failed: {e}")
    
    
    def _preprocess_query(self, user_query: str) -> str:
        """Preprocess user query to fix player names"""
        processed_query = user_query
        for full_name, db_name in self.name_mappings.items():
            pattern = re.compile(re.escape(full_name), re.IGNORECASE)
            processed_query = pattern.sub(db_name, processed_query)
        return processed_query
    
    async def query_gpt_oss(self, user_query: str) -> Optional[str]:
        """Send query to local gpt-oss model via Ollama"""
        processed_query = self._preprocess_query(user_query)
        
        system_prompt = """You are an expert NFL data analyst assistant. Convert natural language queries about NFL play-by-play data into executable SQLite queries.

**Database Schema:**
Table: `plays` with key columns including:
* `passer_player_name`: Quarterback name (FORMAT: "J.Allen", "P.Mahomes", etc.)
* `qb_dropback`: 1 if QB dropped back to pass, 0 otherwise
* `complete_pass`: 1 for completed passes, 0 for incomplete
* `sack`: 1 for sacks, 0 otherwise
* `qb_scramble`: 1 for QB scrambles, 0 otherwise
* `down`: Down number (1, 2, 3, 4)
* `yards_gained`: Yards gained on the play
* `season_type`: 'REG' for regular season, 'POST' for playoffs
* `first_down`: 1 if play resulted in first down, 0 otherwise
* `touchdown`: 1 if play was a touchdown, 0 otherwise
* `qtr`: Quarter (1, 2, 3, 4)

**Player Names - CRITICAL:**
Database uses abbreviated format. Current QBs include: {', '.join(actual_qb_names[:15])}
ALWAYS use the abbreviated format like "J.Goff", "P.Mahomes", "J.Allen" 
NEVER use full names like "Jared Goff" or "Patrick Mahomes"

When unsure about a name, use LIKE '%LastName%' for fuzzy matching.


**Guidelines:**
* Return only the executable SQL query wrapped in ```sql ``` blocks
* Use descriptive column aliases for readability
* Default to regular season unless specified otherwise
* For passing attempts: WHERE qb_dropback = 1 AND sack = 0
* For realistic thresholds: Total attempts 300+, Third down 50+, Red zone 20+
* Always use LIMIT for large result sets (default 10-20 unless specified)
"""

        prompt = f"{system_prompt}\n\nUser query: {processed_query}\nResponse:"
        
        payload = {
            "model": "gpt-oss:20b",
            "prompt": prompt,
            "stream": False
        }
        
        try:
            # Use asyncio for non-blocking request
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None, 
                lambda: requests.post(self.ollama_url, json=payload, timeout=120)
            )
            response.raise_for_status()
            result = json.loads(response.text)
            return result.get('response', '').strip()
        except Exception as e:
            logger.error(f"Ollama request failed: {e}")
            return None
    
    def _extract_sql(self, response: str) -> Optional[str]:
        """Extract SQL code from LLM response"""
        if "```sql" in response:
            try:
                return response.split("```sql")[1].split("```")[0].strip()
            except IndexError:
                pass
        
        # Fallback: look for SELECT statements
        lines = response.split("\n")
        query = ""
        in_query = False
        
        for line in lines:
            if line.strip().upper().startswith('SELECT'):
                in_query = True
            if in_query:
                query += line + " "
                if line.strip().endswith(';'):
                    return query.strip()
        
        return query.strip() if query else None
    
    async def execute_query(self, request: QueryRequest) -> QueryResponse:
        """Execute natural language query and return results"""
        timing = {}
        
        # Check database connection
        if not self.db_connected:
            return QueryResponse(
                success=False,
                error=getattr(self, 'db_error', 'Database not connected'),
                timing=timing
            )
        
        try:
            # Step 1: Get LLM response
            llm_start = time.time()
            llm_response = await self.query_gpt_oss(request.question)
            timing['llm_time'] = time.time() - llm_start
            
            if not llm_response:
                return QueryResponse(
                    success=False,
                    error="Failed to get response from LLM. Make sure Ollama is running.",
                    timing=timing
                )
            
            # Step 2: Extract SQL
            sql_query = self._extract_sql(llm_response)
            if not sql_query:
                return QueryResponse(
                    success=False,
                    error="Could not extract SQL query from LLM response",
                    timing=timing,
                    sql_query=llm_response if request.include_sql else None
                )
            
            # Step 3: Execute query
            db_start = time.time()
            conn = sqlite3.connect(self.db_path, check_same_thread=False)
            df = pd.read_sql_query(sql_query, conn)
            conn.close()
            timing['db_time'] = time.time() - db_start
            timing['total_time'] = timing['llm_time'] + timing['db_time']
            
            # Convert DataFrame to JSON-serializable format
            data = df.to_dict('records')
            columns = df.columns.tolist()
            
            return QueryResponse(
                success=True,
                data=data,
                columns=columns,
                sql_query=sql_query if request.include_sql else None,
                timing=timing,
                rows_returned=len(data)
            )
            
        except Exception as e:
            logger.error(f"Query execution failed: {e}")
            return QueryResponse(
                success=False,
                error=f"Query execution failed: {str(e)}",
                timing=timing,
                sql_query=sql_query if request.include_sql and 'sql_query' in locals() else None
            )

# Global service instance
nfl_service = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global nfl_service
    nfl_service = NFLQueryService('nfl_data_py.db')
    logger.info("NFL Query Service initialized")
    yield
    # Shutdown
    logger.info("NFL Query Service shutting down")

# FastAPI app
app = FastAPI(
    title="üèà NFL Query API",
    description="Natural language interface for NFL statistics using GPT-OSS and 2024 play-by-play data",
    version="1.0.0",
    lifespan=lifespan
)

# CORS middleware for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # React dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API Endpoints
@app.get("/", summary="Root endpoint")
async def root():
    return {
        "message": "üèà NFL Natural Language Query API",
        "version": "1.0.0",
        "endpoints": {
            "/query": "POST - Execute natural language queries",
            "/status": "GET - Check database status",
            "/health": "GET - Health check"
        }
    }

@app.get("/health", summary="Health check")
async def health_check():
    return {"status": "healthy", "timestamp": time.time()}

@app.get("/status", response_model=DatabaseStatus, summary="Get database status")
async def get_status():
    if nfl_service.db_connected:
        return DatabaseStatus(
            connected=True,
            total_plays=nfl_service.total_plays,
            available_quarterbacks=nfl_service.qb_names[:20]  # Return top 20
        )
    else:
        return DatabaseStatus(
            connected=False,
            error=getattr(nfl_service, 'db_error', 'Unknown error')
        )

@app.post("/query", response_model=QueryResponse, summary="Execute natural language query")
async def execute_query(request: QueryRequest):
    if not nfl_service:
        raise HTTPException(status_code=503, detail="Service not initialized")
    
    result = await nfl_service.execute_query(request)
    
    if not result.success and "failed" in result.error.lower():
        raise HTTPException(status_code=400, detail=result.error)
    
    return result

@app.get("/examples", summary="Get example queries")
async def get_examples():
    return {
        "examples": [
            "Top 5 QBs by passing yards",
            "Jared Goff completion percentage", 
            "Third down conversion leaders with minimum 50 attempts",
            "Red zone touchdown percentage for top QBs",
            "QBs with most 300+ yard games",
            "Joe Burrow vs Patrick Mahomes passing stats",
            "Worst interception rate among starting QBs"
        ]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app", 
        host="0.0.0.0", 
        port=8000, 
        reload=True,
        log_level="info"
    )